# 지민

## 별찍기

가운데 별이 위치하고 카운트가 증가할 때마다 양쪽에 별이 하나씩 늘어나는 문제이다.

입력된 숫자만큼 반복을 해야했기에 `for문`을 사용하였다.

`String`타입은 `+`연산자를 사용하면 문자열을 연결 시킬 수 있다는 점과 `*`연산자를 사용해 문자의 개수를 곱할 수 있다는 점을 이용했다.

공백이 점점 줄어들기 때문에 `range`의 `step`을 줄어들게 하는 방법을 사용함

## 달팽이는 올라가고 싶다

처음에는 `while`문을 사용하여 구현하였다

남짜가 오래 안걸리는 날에는 문제가 없었지만 입력3 처럼 오래 걸리는 날에는 시간 초과가 발생하였다.

달팽이가 목표 높이까지 도달하기 전날까지는 다음을 반복한다는 사실을 알게됨

- 낮에는 올라감
- 밤에는 내려감

그래서 `하루에 올라가는 높이`(마지막날 제외)를 `전날 목표 높이`에 나누면 훨씬 빠르게 걸리는 일 수 를 알 수 있었다.

여기서 바로 `day = yesterday_height // one_day_height + 1`을 사용했지만 실패가 나왔다.

고민을 해본 결과 전날 목표 높이까지 걸리는 일수를 계산할 때 나머지가 있다면 올림을 해줘야 한다는 사실을 알게됨

`math`라이브러리를 사용하는 방법을 찾았지만 조건문으로 올림을 하는 방식을 사용하였다.

## 최대공약수와 최소 공배수

#### 최대공약수를 구하는 방법

- 2부터 시작하여 두 수를 계속 나눔
- 더 이상 나눠지지 않으면 이때까지 나눴던 수를 곱하면 최소 공배수가 됨
- 리스트에 넣어서 그 수들을 곱했다.

#### 최소공배수를 구하는 방법

- 양쪽 수에서 작은 수에 2부터 곱해봄
- 계속 곱하면서 두 수가 같아질때까지 곱함

두 수로 최대공약수와 최소공배수를 같이 찾아야하기 때문에 입력받은 두 수를 다른 변수에 할당하여 문제를 품

변수의 이름을 비슷하게 사용하였는데 헷갈려서 이름을 다시 바꿈

## 평균

과목 별 원래 점수를 리스트로 할당하고 `max`함수를 사용하여 최고점을 구했다

리스트 컴프리헨션을 사용하여 새로 조작한 점수 리스트를 만들었다.

새로운 점수 리스트로 평균을 새로 구하였다.

## 색종이

종이가 놓여질 수 있는 평면은 최대 가로 101칸 세로 101칸이기 때문에 먼저 평면을 2차원 배열로 만들었다. -> 최대 1001칸이었다.

주어진 색종이의 순서에 따라 입력받은 좌표값에 높이와 너비만큼 반복하여 색종이를 칠해주었다.

평면을 모두 순회하면서 각 색종이의 번호를 `count`하여 색종이들의 면적을 구했다.

> 42점이 나왔다.

- 입력조건을 잘못봤다
- 1001을 넣으니 성공하였다

## 딱지놀이

서로가 낸 딱지의 모양의 우선순위에 따라 승패를 출력하는 문제

딱지의 모양별로 개수를 카운팅해 비교한다.

`index`로 추가해주기 위해 `index:0`을 더미로 추가해서 만든다.

어린이가 낸 딱지의 모양을 모양 개수 리스트에 카운팅 해준다.

모양 개수 리스트를 순회하며 두 어린이의 승패를 결정한다.

실수

- 두 어린이의 입력값의 첫번째는 카드의 개수였는데 문제를 잘 못 읽고 카드 카운팅에 추가하였다.
- 승패를 결정하는 반복문의 범위가 4->3->2->1로 가야하는데 잘못해서 시간이 좀 걸렸다.

## 자리배정

좌석을 시계방향으로 배치에 원하는 좌석의 x, y 좌표값을 알아내는 문제

처음에는 4방향을 각각 `for문`을 돌려 좌석을 배치하려 했지만 `range`의 범위가 너무 복잡해졌다.

그래서 각 방향을 변수로 만들고 각 방향에 따라 인덱스를 변화시켜주어 좌석을 배치했다.

하지만 이 방법도 복잡도가 높고 범위의 계산이 어렵다는 단점이 있다.

추후에 다른 방법을 생각해보는 것이 좋을듯하다.

## 나무꾼 이다솜

나무를 자를수도 있고 그냥 팔수도 있을 때 최댓값을 구하는 문제

토막 단위를 1부터 제일 긴 나무의 길이까지 완전 탐색하여 최댓값을 구했다.

처음에는 토막 단위보다 나무가 길다면 무조건 잘라주었는데 자르는 비용이 크다면 오히려 마이너스가 된다.

따라서 자르는게 이득인지 안자르는게 이득인지 확인하고 풀어야한다.

- 자르는 횟수(깔끔하게 잘린다면) = 나무길이 // 토막단위 - 1
- 자르는 횟수(나머지가 있다면) = 나무길이 // 토막단위

> 반례
>
> 4 1000 1
>
> 2
>
> 1
>
> 1
>
> 1


## 빙고
빙고판에서 몇번째 숫자에서 빙고가 되는지 출력하는 문제

빙고가 되기 위해 필요한 숫자는 최소 12개이다.

12개 이후부터는 하나씩 숫자를 체크하고 빙고인지 확인하는 함수를 만들었다.

3줄이면 빙고로 만들었는데 정 가운데 번호가 마지막에 불리면 4줄 빙고가 만들어질 수 있다 -> 3줄 이상이면 빙고이다.


## 2116 주사위 쌓기
주사위를 쌓을 때 한쪽 면의 최댓값을 구하는 문제

밑의 주사위의 윗면의 숫자와 위의 주사위의 아랫면의 숫자가 같아야 한다

맞은편 숫자끼리 정렬을 해준다

맨 밑의 주사위의 아랫면 숫자가 정해지면 나머지 주사위가 놓아지는 건 정해진다

따라서 맨 밑의 주사위의 아랫쪽 숫자를 1부터 6까지 정해주면서 구해준다

최고값을 구하기위해 각 주사위의 아랫면과 윗면의 숫자는 맨 뒤로 보내준 뒤 구해준다. 


## 1244 스위치 켜고 끄기
학생들이 스위치를 켜고 끌 때 마지막 스위치 상태를 출력하는 문제

배수와 대칭을 사용하는 문제

번호의 배수라서 `range`의 `step`을 적절히 사용하여 풀었다

결과값을 출력하기 위해 `' '.join(리스트)`를 사용하였는데 `int`리스트는 사용할 수 없었다. 따라서 `map(str, 정수리스트)`로 정수를 문자열로 바꿔준 뒤 출력하였다.
