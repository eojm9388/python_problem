# 지민

## 별찍기

가운데 별이 위치하고 카운트가 증가할 때마다 양쪽에 별이 하나씩 늘어나는 문제이다.

입력된 숫자만큼 반복을 해야했기에 `for문`을 사용하였다.

`String`타입은 `+`연산자를 사용하면 문자열을 연결 시킬 수 있다는 점과 `*`연산자를 사용해 문자의 개수를 곱할 수 있다는 점을 이용했다.

공백이 점점 줄어들기 때문에 `range`의 `step`을 줄어들게 하는 방법을 사용함

## 달팽이는 올라가고 싶다

처음에는 `while`문을 사용하여 구현하였다

남짜가 오래 안걸리는 날에는 문제가 없었지만 입력3 처럼 오래 걸리는 날에는 시간 초과가 발생하였다.

달팽이가 목표 높이까지 도달하기 전날까지는 다음을 반복한다는 사실을 알게됨

- 낮에는 올라감
- 밤에는 내려감

그래서 `하루에 올라가는 높이`(마지막날 제외)를 `전날 목표 높이`에 나누면 훨씬 빠르게 걸리는 일 수 를 알 수 있었다.

여기서 바로 `day = yesterday_height // one_day_height + 1`을 사용했지만 실패가 나왔다.

고민을 해본 결과 전날 목표 높이까지 걸리는 일수를 계산할 때 나머지가 있다면 올림을 해줘야 한다는 사실을 알게됨

`math`라이브러리를 사용하는 방법을 찾았지만 조건문으로 올림을 하는 방식을 사용하였다.

## 최대공약수와 최소 공배수

#### 최대공약수를 구하는 방법

- 2부터 시작하여 두 수를 계속 나눔
- 더 이상 나눠지지 않으면 이때까지 나눴던 수를 곱하면 최소 공배수가 됨
- 리스트에 넣어서 그 수들을 곱했다.

#### 최소공배수를 구하는 방법

- 양쪽 수에서 작은 수에 2부터 곱해봄
- 계속 곱하면서 두 수가 같아질때까지 곱함

두 수로 최대공약수와 최소공배수를 같이 찾아야하기 때문에 입력받은 두 수를 다른 변수에 할당하여 문제를 품

변수의 이름을 비슷하게 사용하였는데 헷갈려서 이름을 다시 바꿈

## 평균

과목 별 원래 점수를 리스트로 할당하고 `max`함수를 사용하여 최고점을 구했다

리스트 컴프리헨션을 사용하여 새로 조작한 점수 리스트를 만들었다.

새로운 점수 리스트로 평균을 새로 구하였다.

## 색종이

종이가 놓여질 수 있는 평면은 최대 가로 101칸 세로 101칸이기 때문에 먼저 평면을 2차원 배열로 만들었다. -> 최대 1001칸이었다.

주어진 색종이의 순서에 따라 입력받은 좌표값에 높이와 너비만큼 반복하여 색종이를 칠해주었다.

평면을 모두 순회하면서 각 색종이의 번호를 `count`하여 색종이들의 면적을 구했다.

> 42점이 나왔다.

- 입력조건을 잘못봤다
- 1001을 넣으니 성공하였다

## 딱지놀이

서로가 낸 딱지의 모양의 우선순위에 따라 승패를 출력하는 문제

딱지의 모양별로 개수를 카운팅해 비교한다.

`index`로 추가해주기 위해 `index:0`을 더미로 추가해서 만든다.

어린이가 낸 딱지의 모양을 모양 개수 리스트에 카운팅 해준다.

모양 개수 리스트를 순회하며 두 어린이의 승패를 결정한다.

실수

- 두 어린이의 입력값의 첫번째는 카드의 개수였는데 문제를 잘 못 읽고 카드 카운팅에 추가하였다.
- 승패를 결정하는 반복문의 범위가 4->3->2->1로 가야하는데 잘못해서 시간이 좀 걸렸다.

## 자리배정

좌석을 시계방향으로 배치에 원하는 좌석의 x, y 좌표값을 알아내는 문제

처음에는 4방향을 각각 `for문`을 돌려 좌석을 배치하려 했지만 `range`의 범위가 너무 복잡해졌다.

그래서 각 방향을 변수로 만들고 각 방향에 따라 인덱스를 변화시켜주어 좌석을 배치했다.

하지만 이 방법도 복잡도가 높고 범위의 계산이 어렵다는 단점이 있다.

추후에 다른 방법을 생각해보는 것이 좋을듯하다.

## 나무꾼 이다솜

나무를 자를수도 있고 그냥 팔수도 있을 때 최댓값을 구하는 문제

토막 단위를 1부터 제일 긴 나무의 길이까지 완전 탐색하여 최댓값을 구했다.

처음에는 토막 단위보다 나무가 길다면 무조건 잘라주었는데 자르는 비용이 크다면 오히려 마이너스가 된다.

따라서 자르는게 이득인지 안자르는게 이득인지 확인하고 풀어야한다.

- 자르는 횟수(깔끔하게 잘린다면) = 나무길이 // 토막단위 - 1
- 자르는 횟수(나머지가 있다면) = 나무길이 // 토막단위

> 반례
>
> 4 1000 1
>
> 2
>
> 1
>
> 1
>
> 1


## 빙고
빙고판에서 몇번째 숫자에서 빙고가 되는지 출력하는 문제

빙고가 되기 위해 필요한 숫자는 최소 12개이다.

12개 이후부터는 하나씩 숫자를 체크하고 빙고인지 확인하는 함수를 만들었다.

3줄이면 빙고로 만들었는데 정 가운데 번호가 마지막에 불리면 4줄 빙고가 만들어질 수 있다 -> 3줄 이상이면 빙고이다.


## 2116 주사위 쌓기
주사위를 쌓을 때 한쪽 면의 최댓값을 구하는 문제

밑의 주사위의 윗면의 숫자와 위의 주사위의 아랫면의 숫자가 같아야 한다

맞은편 숫자끼리 정렬을 해준다

맨 밑의 주사위의 아랫면 숫자가 정해지면 나머지 주사위가 놓아지는 건 정해진다

따라서 맨 밑의 주사위의 아랫쪽 숫자를 1부터 6까지 정해주면서 구해준다

최고값을 구하기위해 각 주사위의 아랫면과 윗면의 숫자는 맨 뒤로 보내준 뒤 구해준다. 


## 1244 스위치 켜고 끄기
학생들이 스위치를 켜고 끌 때 마지막 스위치 상태를 출력하는 문제

배수와 대칭을 사용하는 문제

번호의 배수라서 `range`의 `step`을 적절히 사용하여 풀었다

결과값을 출력하기 위해 `' '.join(리스트)`를 사용하였는데 `int`리스트는 사용할 수 없었다. 따라서 `map(str, 정수리스트)`로 정수를 문자열로 바꿔준 뒤 출력하였다.


## 2605 줄세우기
학생들이 뽑은 번호의 규칙대로 줄을 세워 구하는 문제

리스트를 사용하여 학생이 뽑은 번호만큼 보관해뒀다가 줄을 세운 뒤 리스트의 학생들을 다시 줄 세우는 방식으로 풀었다

`insert(index)`방식도 사용 가능


## 2309 일곱 난쟁이
아홉 난쟁이들 중 조건에 맞는 일곱 난쟁이를 찾는 문제

부분 집합을 만들고 조건에 맞는 부분 집합을 구하였다.

비트 연산을 사용하여 부분 집합을 만들었다.


## 2564 경비원
각 상점까지 갈 수 있는 최단거리의 합을 구하는 문제

각 방향과 거리에 따라 모든 조건을 구해주었다.

특정 규칙이 있을거 같았지만 찾지 못함


## 30892 상어키우기
상어가 앞바다의 상어들을 먹으면서 크기를 키운다. 키울 수 있는 상어의 최대 크기를 구하는 문제

내림차순 정렬을 한 뒤 먹을 수 있는 제일 큰 상어를 먹는다

만약 앞바다에서 제일 큰 상어가 현재 상어보다 작다면 모든 상어를 먹을 수 있음
- 가지치기가 중요한 문제


## 7576 토마토
토마토가 모두 익을 때까지 걸리는 일 수를 구하는 문제

BFS를 사용하는데 출발점이 여러 곳인 문제

시작할 때 출발점을 모두 큐에 넣어놓고 풀면 된다.

익지 않은 토마토가 있을 가능성도 생각해야한다.


## 1697 숨바꼭질
수빈이가 몇초만에 동생을 찾을 수 있는지 구하는 문제

완전이진트리로 생각할 수 있다

BFS를 사용하여 풀 수 있다


## 11729 하노이 탑 이동 순서
하노이 탑 이동 순서를 출력하는 문제

이 문제는 재궈적으로 풀어야 한다. 원판을 생각하는 것이 아니라 원판을 옮길 기둥을 생각하고 풀어야 하는 문제

함수 로직
- n-1개의 원판을 시작기둥에서 임시 기둥으로 놓는다
- n번째 원판을 시작기둥에서 도착 기둥으로 놓는다.
- n-1개의 원판을 임시 기둥에서 도착 기둥으로 놓는다.

이 사이클을 한번 돌면 n번째 원판이 도착 기둥에 놓여진다.


## 1074 Z
Z방향으로 이동할 때 r, c가 몇번째로 가는지 구하는 문제

재귀함수를 사용해서 푼다

큰 문제를 작은 문제로 생각해서 푼다.

r, c가 2**n 박스에서 1, 2, 3, 4분면 중 어디에 있는지 본다
- 1사분면 -> f(i, j, n-1)
- 2사분면 -> half*halt + f(i, j-half, n-1)
- 3사분면 -> 2*half*half + f(i-half, j, n-1)
- 4사분면 -> 3*half*half + f(i-half, j-half, n-1)

이 상황이 n=0이 될때까지 진행됨


## 13549 숨바꼭질
1697의 숨바꼭질 업그레이드 버전

순간이동은 시간이 지나지 않는다.

범위를 잘 선정해주어야한다.

순간이동은 0초가 걸리기 때문에 제일 먼저 해주어야 한다.


## 2606 바이러스
바이러스가 침투한 컴퓨터의 개수를 구하는 문제

무방향 그래프 문제

DFS를 사용하여 방문처리를 해줌 -> 방문처리 된 컴퓨터는 감염된 컴퓨터이다.


## 2579 계단 오르기
가장 점수를 많이 얻을 수 있는 방법을 찾는 문제

- 계단을 3칸이상 연속으로 오를 수 없다
- 마지막 칸에는 도달해야한다.

이 문제는 마지막 칸에 도달해야한다는 조건이 있기 때문에 마지막부터 생각해주면 좀 쉽다.

마지막 계단을 가는 경우의 수
- `dp[i] = dp[i-3] + 계단[i-1] + 계단[i]`
- `dp[i] = dp[i-2] + 계단[i]`
  

## 1932 정수 삼각형
대각선 아래로 내려오면서 더한 수의 값이 최대가 되는 값을 구하는 문제

- 위의 왼쪽, 위의 오른쪽 중 큰 값과 자신의 더한 값이 최대이다 (범위안에서)
- 2차원 리스트로 만들어 마지막 줄의 최댓값을 구하면 된다.
## 4673 셀프 넘버
생성자 수가 없는 수들만 출력하는 문제

1부터 10000까지 수를 다 생성해서 리스트에 저장한다.

1부터 10000까지 리스트에 수가 없다면 출력한다


## 2468 안전영역
물에 잠기지 않는 영역의 개수의 최댓값을 구하는 문제

물의 높이를 0부터 시작하여 안전한 영역의 개수를 구해주었다
- BFS를 사용함
- 안전한 영역만큼 visited가 방문처리 된다
- 안잠기는 곳이 있을 수도 있기 때문에 0부터 시작해야함

연산 횟수를 줄이기 위해 지역의 최대 높이를 구해준 뒤 물의 높이를 지역의 최대높이까지 진행해주었다


## 1065 한수
N이하의 수들 중 한수의 개수를 구하는 문제

한수인지를 True/False로 반환해주는 함수를 만듬
- 1자리 숫자면 무조건 True
- 2자리부터 문자열로 받아 등차수열인지를 보았다
- for문을 사용하여 만약 for문안에서 등차수열이 아니라면 reture False
- for문을 다 통과했다면 한수임으로 return True


## 1003 피보나치 함수
피보나치 수를 구할 때 호출되는 `f(0)`과 `f(1)`을 개수를 구하는 문제

`DP`를 사용하여 풀었다.

M이 2이상이라면 자신이 가지는 1과 0의 개수는 (M-1의 1과 0의 개수) + (M-2의 1과 0의 개수)이다.


## 1149 RGB 거리
다시 풀어봐야함


## 1463 1로 만들기
1 빼기, 2로 나누기, 3으로 나누기 중 선택하여 1을 만들 수 있는 가장 적은 횟수를 구하는 문제

`a[i] 의 최솟값은 d[i-1]+1, d[i//2]+1, d[i//3]+1 중에 하나이다`
- 이때 i//2나 i//3은 나눠졌을 때 가능하다


## 11399 ATM
사람들이 돈을 뽑는 시간이 최소일 때를 구하는 문제

대기시간이 작은 순서대로 정렬한 후 더해준다.


## 11047 동전 0
동전의 개수를 최소로 구하는 문제

- 동전의 금액이 배수로 정해져있다.
- 큰 동전부터 거슬러가면 된다.


## 1931 회의실 배정
회의할 수 있는 최대 횟수를 구하는 문제

- 회의시간이 담긴 2차원 리스트를 오름차순 정렬 - 시작시간이 작은 순으로 정렬(같은값: 종료시간이 작은 순)
- 첫번째부터 회의를 한다고 가정
- 만약 다음 회의 시작시간이 현재 회의 종료시간보다 크다면 다음 회의 진행
- 아니라면 종료시간을 비교해서 작은 시간으로 종료시간을 갱신


## 1541 잃어버린 괄호
수식에 괄호를 쳐서 최소값을 구하는 문제

- `-`뒤에 수들에 괄호를 쳐서 구하면 최솟값을 구할 수 있다.


## 16953 A -> B
A에서 B로 만들 수 있는 최소 연산 횟수를 구하는 문제

연산
- A를 2 곱한다
- A의 오른쪽에 1을 붙인다

B에서 A를 만드는 방식으로 생각했다

B의 오른쪽이 1이 아닌데 홀수라면 A로 B를 만들 수 없다
- B의 오른쪽이 1이 아니면 짝수다
  

## 16918 봄버맨
시간에 따라 폭탄의 위치를 구하는 문제

- 시간에 따라 반복되는 2차원 리스트를 찾는 문제다
- 홀수와 짝수를 나눠서 생각해야한다.
- 주기가 몇인지를 생각해보자
- 델타 탐색으로 폭탄을 터뜨릴 경우 나중에 터질 폭탄도 계산하자


## 15650 N과 M(2)
오름차순으로 정렬한 중복 없는 순열을 구하는 문제

중복 없는 순열을 만들어준 뒤 오름차순으로 정렬하고 중복 제거를 한 뒤 출력한다.


## 13335 트럭
트럭이 다리를 건널 때까지 걸리는 최소 시간을 구하는 문제

선입선출의 큐를 사용하여 구현함

처음 다리에 큐를 0으로 모두 채워 넣어 만듬

트럭이 모두 지날 갈때까지 조건에 맞게 넣어준다

트럭이 모두 지나갔다면 다리에 남은 트럭이 지나갈때까지 시간을 더해준다


## 2164 카드2
마지막에 남은 카드를 구하는 문제

- 맨위 카드를 버린다
- 그 다음 카드를 맨 마지막으로 넘긴다

선입선출의 자료구조인 큐로 구현해서 풀었다


## 7568 덩치
키와 몸무게가 주어질 때 자신보다 덩치가 큰 사람의 수를 구하는 문제

이중 반복문을 사용하여 자신보다 덩치 큰 사람이 있을 경우 1를 증가시킴


## 1158 요세푸스 문제
원형의 수들 중 K번째 수를 계속해서 빼는 방법

큐를 사용하여 원형을 구현하였다