## 1206 View

조망권이 확보되기 위해서는 양쪽의 거리가 2인 부분에 빌딩이 가리지 않아야한다.

빌딩을 하나씩 순회하면서 양쪽 거리 2만큼의 숫자가 작은지를 확인해야한다.

만약 하나라도 자신보다 높은 빌딩이 있다면 조망권은 확보되지 않는다.

그 후 자신의 빌딩중에서 조망권이 확보된 세대의 수는 양쪽 거리 2만큼의 빌딩 중 제일 높은 빌딩을
자신의 빌딩 높이에서 뺀 만큼이다.

모든 빌딩을 순회하면서 조망권이 있는 세대수의 총합을 구한다.


## 4828 min max 

숫자 리스트를 받아와 `max`와 `min` 메서드를 사용하여 최댓값과 최솟값을 구한다.


## 4835 구간합

M개의 이웃한 숫자의 합들 중 제일 작은 값과 큰 값을 구하는 문제

맨 처음에 비교할 값을 인덱스의 첫번째 값부터 시작했다. 

리스트 슬라이싱을 하면서 이웃한 숫자들의 합을 구하고 최대, 최소값과 비교한다.


## 1208 Flatten

주어진 덤프 수만큼 가장 높은 박스의 박스를 가장 낮은 박스에 옮긴 후 높이차를 구하는 문제

먼저 박스의 높이별로 카운트를 한 리스트를 만들었다.

먼저 낮은 높이의 박스에 덤프를 하여 높이를 높여주고 다시 덤프를 수행해 높은 높이의 박스의 높이를 감소시켰다.

덤프가 마무리 된 후 가장 높은 높이의 박스와 낮은 박스의 차이를 구했다.


## 4834 숫자카드

카드가 나올 수 있는 제일 큰 수가 9이기 때문에 0부터 9까지 나온 카드의 개수를 셀 수 있는 리스트를 만든다.

나온 카드를 순회하면서 나온 카드를 카드 개수 리스트를 증가시킨다.

나온 카드의 최대 개수가 같다면 그 중 높은 카드의 숫자를 얻어야하기 때문에

카드 개수 리스트를 `reverse`하고 `index`로 찾아주었다.

나온 `index`를 9에 빼주면 가장 많이 나온 카드 중 제일 큰 수를 얻을 수 있다.


## 9490 풍선팡

풍선 배열의 모든 값을 비교해봐야하기 때문에 함수로 만들었다.

가로방향과 세로방향의 반복문을 따로 순회하여 꽃가루의 총합을 구했다.

만약 배열의 벗어나는 범위하면 `continue`로 스킵한다.

가운데 중앙값은 중복되므로 결과값에서 한번 빼주었다.

모든 풍선배열을 순회하면서 최대 꽃가루 총합을 구한다.


## 4831 전기버스

전기버스가 최소로 몇번 충전소를 거쳐야 도착지점에 가는지 문제

먼저 이동가능여부를 확인하는 코드를 함수로 만드는 것이 좋겠다고 생각하였다.

함수에서 확인해보아야할 것
- 전기버스가 도착지점에 도달했는가
- 전기버스의 이동거리내에 충전소가 있는가
- 만약 2개 이상이라면 제일 나중에 있는 충전소에서 충전하는것이 최소한으로 충전소를 간다.

함수에서 이동가능여부와 이동한 거리를 반환해주면 좋겠다고 생각함

반환값을 튜플로 맞춰주기 위해서 이동 불가에도 이동거리를 0으로 해서 줌

반복문을 돌면서 조건을 확인하며 이동거리를 다시 함수에 할당한다.

> 이동거리의 범위들과 횟수가 헷갈린다.


